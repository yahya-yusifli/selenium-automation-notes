**1) Target the first input that appears after a heading (not a sibling)**

**Goal:** Select the **first input** that appears after the “billing” heading.

**HTML**

```html
<section id="payment">
  <h2>billing</h2>
  <p>please enter your payment details below.</p>
  <div class="grid">
    <label>card number</label>
    <input type="text" name="cardNumber">
  </div>
</section>
```

**XPath (can jump beyond siblings)**

```
//h2[normalize-space()='billing']/following::input[1]
```

**CSS (no direct equivalent; use container anchor)**

```css
#payment h2 + p + .grid input[name="cardNumber"] /* fragile chain */
#payment input[name="cardNumber"]                /* robust if container is stable */
```

**Playwright (prefer XPath for clarity)**

```tsx
const card = page.locator("//h2[normalize-space()='billing']/following::input[1]");
```

---

**2) Pick an element by stable label text when the input id is dynamic**

**Goal:** Capture the username input by **label text** when the input id changes.

**HTML**

```html
<form id="loginForm">
  <div class="row">
    <label for="u_4821">username</label>
    <input id="u_4821" type="text" data-testid="username">
  </div>
</form>
```

**XPath (text → following-sibling)**

```
//label[normalize-space()='username']/following-sibling::input
```

**CSS (no text match; rely on attribute)**

```css
[data-testid="username"]
```

**Playwright**

```tsx
const username = page.getByLabel('username'); // preferred
const usernameAttr = page.locator('[data-testid="username"]');
```

---

**3) Find the table cell under a given header (header text → column cells)**

**Goal:** Select **all cells** under the “email” column.

**HTML**

```html
<table id="users">
  <thead>
  <tr><th>name</th><th>email</th><th>role</th></tr>
  </thead>
  <tbody>
  <tr><td>alice</td><td>alice@example.com</td><td>admin</td></tr>
  <tr><td>bob</td><td>bob@example.com</td><td>user</td></tr>
  </tbody>
</table>
```

**XPath (header index → td in each row)**

```
//table[@id='users']//tr/td[ count(../preceding-sibling::tr[1]/th[normalize-space()='email']/preceding-sibling::th) + 1 ]
```

**CSS (pure CSS can’t compute header index) — Playwright helper**

```tsx
const emailHeader = page.locator('#users thead th', { hasText: 'email' });
const idx = await emailHeader.evaluate(el => [...el.parentElement!.children].indexOf(el));
const emailCells = page.locator(`#users tbody tr td:nth-child(${idx + 1})`);
```

---

**4) Select nth logical item among mixed nodes (indexing safely)**

**Goal:** Select the **3rd** product card when other nodes are mixed in.

**HTML**

```html
<div class="list">
  <h3>featured</h3>
  <article class="card">a</article>
  <article class="card">b</article>
  <div class="ad">sponsor</div>
  <article class="card">c</article>
</div>
```

**XPath (filter then index)**

```
(//article[contains(@class,'card')])[3]
```

**CSS**

```css
.list > article.card:nth-of-type(3) /* works only if siblings are same tag group */
```

**Playwright**

```tsx
const thirdCard = page.locator('article.card').nth(2);
```

---

**5) Traverse from a row label to its associated input in complex forms**

**Goal:** Select the **input** in the “tax id” row inside a grid form.

**HTML**

```html
<div class="form-grid">
  <div class="row">
    <div class="col label">company name</div>
    <div class="col field"><input name="company"></div>
  </div>
  <div class="row">
    <div class="col label">tax id</div>
    <div class="col field"><input name="taxId"></div>
  </div>
</div>
```

**XPath (row by label → descendant input)**

```
//div[@class='row'][.//div[contains(@class,'label')][normalize-space()='tax id']]
     //div[contains(@class,'field')]//input
```

**CSS (use :has() to lock the row)**

```css
.row:has(.label:has-text("tax id")) .field input
```

**Playwright**

```tsx
const taxInput = page.locator(".row:has(.label:has-text('tax id')) .field input");

```

---

**6) Restrict a descendant search to a specific ancestor (avoid overmatching)**

**Goal:** Select the **save** button only inside the “profile” panel.

**HTML**

```html
<section id="profile">
  <button class="btn">save</button>
</section>
<section id="notifications">
  <button class="btn">save</button>
</section>
```

**XPath (scoped)**

```
//section[@id='profile']//button[normalize-space()='save']
```

**CSS**

```css
#profile .btn
```

**Playwright (text + scope)**

```tsx
const save = page.locator('#profile').getByRole('button', { name: 'save' });
```

---

**7) Conditional traverse with state (choose the input whose checkbox is checked)**

**Goal:** Select the **notes** input in the row where the checkbox is checked.

**HTML**

```html
<div class="row">
  <input type="checkbox" name="optA" checked>
  <input type="text" name="notesA">
</div>
<div class="row">
  <input type="checkbox" name="optB">
  <input type="text" name="notesB">
</div>
```

**XPath (state + sibling)**

```
//div[@class='row'][.//input[@type='checkbox' and @checked]]
     //input[@type='text']
```

**CSS (state with :has())**

```css
.row:has(input[type="checkbox"]:checked) input[type="text"]
```

**Playwright**

```tsx
const notes = page.locator('.row:has(input[type="checkbox"]:checked) input[type="text"]');
```

---

**8) From error message to its owning input (reverse association)**

**Goal:** Select the **input** related to the “email is required” error.

**HTML**

```html
<div class="field">
  <label for="email">email</label>
  <input id="email" name="email">
  <div class="error">email is required</div>
</div>
```

**XPath (sibling → preceding input)**

```
//div[contains(@class,'error') and normalize-space()='email is required']
  /preceding-sibling::input[1]
```

**CSS (no backward selection; use container)**

```css
.field:has(.error) input#email
```

**Playwright**

```tsx
const emailInput = page.locator(".field:has(.error) input#email");
```

---

**9) Shadow dom: select inside a component**

**Goal:** Select the **edit** button inside the `<user-card>` component.

**HTML**

```html
<user-card></user-card>
<!-- inside shadow dom:
  <div class="menu">
    <button class="edit">edit</button>
  </div>
-->
```

**XPath**

Native XPath cannot traverse shadow DOM directly.

**Playwright (pierce shadow)**

```tsx
const edit = page.locator('user-card').locator('>>> button.edit');
```

**CSS (in Playwright)**

```tsx
const edit2 = page.locator('user-card >>> button.edit');
```

---

**10) Role-based and accessible traversing (more resilient)**

**Goal:** Select the **continue** button inside a dialog with accessible roles.

**HTML**

```html
<div role="dialog" aria-label="checkout dialog">
  <button>cancel</button>
  <button>continue</button>
</div>
```

**XPath (by text, scoped to dialog)**

```
//*[@role='dialog']//button[normalize-space()='continue']
```

**Playwright (preferred)**

```tsx
const dialog = page.getByRole('dialog', { name: 'checkout dialog' });
const continueBtn = dialog.getByRole('button', { name: 'continue' });
```

---

**11) Complex grid: header + row key → specific cell**

**Goal:** Select the **price** cell for the “macbook pro” row.

**HTML**

```html
<table id="catalog">
  <thead><tr><th>product</th><th>price</th><th>stock</th></tr></thead>
  <tbody>
    <tr><td>macbook air</td><td>$999</td><td>5</td></tr>
    <tr><td>macbook pro</td><td>$1999</td><td>2</td></tr>
  </tbody>
</table>
```

**XPath (row by product text → column by header index)**

```
//table[@id='catalog']//tr[td[normalize-space()='macbook pro']]
/td[ count(../../thead/tr/th[normalize-space()='price']/preceding-sibling::th) + 1 ]
```

**Playwright (compute indices in code)**

```tsx
const row = page.locator('#catalog tbody tr', { hasText: 'macbook pro' });
const priceCell = row.locator('td').nth(1);
```

---

**12) Negative selection: find a card that does not have a “sold out” badge**

**Goal:** Select the **first product card** without a “sold out” badge.

**HTML**

```html
<div class="card">
  <h4>product a</h4><span class="badge sold-out">sold out</span>
</div>
<div class="card">
  <h4>product b</h4>
</div>
```

**XPath (negation with not())**

```
(//div[contains(@class,'card')][not(.//span[contains(@class,'sold-out')])])[1]
```

**CSS (Playwright supports :has() for negation)**

```tsx
const available = page.locator('.card:not(:has(.sold-out))').first();
```
